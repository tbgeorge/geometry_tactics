//=================================================================================
// HealBehavior.cpp
// Author: Tyler George
// Date  : November 15, 2015
//=================================================================================

////===========================================================================================
///===========================================================================================
// Includes
///===========================================================================================
////===========================================================================================

#include "GameCode/AI/AIBehaviors/HealBehavior.hpp"
#include "GameCode/Entities/Actor.hpp"
#include "GameCode/CombatManager.hpp"


////===========================================================================================
///===========================================================================================
// Static Variable Initialization
///===========================================================================================
////===========================================================================================

AIBehaviorRegistration HealBehavior::s_healBehaviorRegistration( "Heal", &HealBehavior::CreateAIBehavior );


////===========================================================================================
///===========================================================================================
// Constructors/Destructors
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
HealBehavior::HealBehavior( const std::string& name, const XMLNode& behaviorRoot )
    : BaseAIBehavior( name, behaviorRoot )
    , m_chanceToHit( 1.0f )
    , m_chanceToCrit( 0.2f )
    , m_target( nullptr )
{
    m_healRange = GetIntIntervalProperty( behaviorRoot, "damage" );
    m_chanceToHit = GetFloatProperty( behaviorRoot, "chanceToHit", 1.0f );
    m_chanceToCrit = GetFloatProperty( behaviorRoot, "chanceToCrit", 0.0f );
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
HealBehavior::HealBehavior( const HealBehavior& copy )
    : BaseAIBehavior( copy.m_name )
{
    m_chanceToCalcUtility = copy.m_chanceToCalcUtility;
    m_healRange = copy.m_healRange;
    m_chanceToHit = copy.m_chanceToHit;
    m_chanceToCrit = copy.m_chanceToCrit;
    m_target = copy.m_target;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
HealBehavior::~HealBehavior()
{

}

////===========================================================================================
///===========================================================================================
// Initialization
///===========================================================================================
////===========================================================================================


////===========================================================================================
///===========================================================================================
// Accessors/Queries
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
BaseAIBehavior* HealBehavior::CreateAIBehavior( const std::string& name, const XMLNode& behaviorRoot )
{
    return new HealBehavior( name, behaviorRoot );
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
float HealBehavior::CalcUtility()
{
    if (m_actor->GetActState() == HAS_ACTED)
        return 0.0f;

    bool calcUtility = GetRandomFloatZeroToOne() <= m_chanceToCalcUtility ? true : false;

    if (!calcUtility)
        return 0.0f;

    // Getting possible attack locations
    CellPtrs attackPositions = m_actor->GetPossibleAttacks();


    // finding a valid target
    Actor* friendlyTarget = nullptr;

    Actors allActors = m_actor->GetMap()->GetAllActors();

    for (Actors::iterator actorIter = allActors.begin(); actorIter != allActors.end(); ++actorIter)
    {
        Actor* actor = *actorIter;

        if (actor == m_actor)
            continue;

        Faction actorFaction = actor->GetFaction();
        MapPosition actorPos = actor->GetMapPosition();

        for (CellPtrs::iterator cellIter = attackPositions.begin(); cellIter != attackPositions.end(); ++cellIter )
        {
            Cell* cell = *cellIter;
            MapPosition cellPos = cell->GetMapPosition();

            if (actorPos == cellPos)
            {
                if (actorFaction == m_actor->GetFaction() && ((friendlyTarget && actor->GetHealth() < friendlyTarget->GetHealth()) || !friendlyTarget) && actor->GetHealth() != actor->GetMaxHealth() )
                {
                    friendlyTarget = actor;
                    break;
                }
            }
        }
    }

    if (friendlyTarget)
    {
        m_target = friendlyTarget;
        return 11.0f;
    }
    else
    {
        m_target = nullptr;
        return 0.0f;
    }
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void HealBehavior::Think()
{
    if (m_target)
    {
//         AttackData data;
//         data.attacker = m_actor;
//         data.target = m_target;
//         data.chanceToCrit = m_chanceToCrit;
//         data.chanceToHit = m_chanceToHit;
//         data.healRange = m_healRange;
//         data.armorRange = IntRange::ZERO;

        m_actor->AttackPosition( m_target->GetMapPosition() );
        m_target = nullptr;

//         AttackResult result = CombatManager::PerformHeal( data );
    }
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
BaseAIBehavior* HealBehavior::Clone()
{
    BaseAIBehavior* clone = new HealBehavior( *this );

    return clone;
}

////===========================================================================================
///===========================================================================================
// Mutators
///===========================================================================================
////===========================================================================================


////===========================================================================================
///===========================================================================================
// Update
///===========================================================================================
////===========================================================================================


////===========================================================================================
///===========================================================================================
// Render
///===========================================================================================
////===========================================================================================


////===========================================================================================
///===========================================================================================
// Private Functions
///===========================================================================================
////===========================================================================================

